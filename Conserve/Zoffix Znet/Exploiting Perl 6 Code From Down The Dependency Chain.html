https://perl6.party//post/Exploiting-Perl-6-Code-From-Down-The-Dependency-Chain
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:image"
        content="https://rakudo.party/assets/pics/perl6.party.gif">
    <meta name="twitter:image" content="https://rakudo.party/assets/pics/perl6.party.gif">
    <title>Exploiting Perl 6 Code From Down The Dependency Chain - Perl 6 Party</title>

    <link href="/asset/7b8e23928d/app.css" rel="stylesheet">
  </head>

  <body>

    <div class="blog-masthead">
      <div class="container">
        <nav class="blog-nav">
          <a class="blog-nav-item " href="/">Home</a>
          <a class="blog-nav-item " href="/about">About</a>
          <a class="blog-nav-item feed-nav" href="/feed/">Feed</a>
        </nav>
      </div>
    </div>

    <div class="bg">
        <div class="container">

          <div class="blog-header">
            <h1 class="blog-title">Exploiting Perl 6 Code From Down The Dependency Chain</h1>
          </div>

          <div class="row">
            <div class="col-sm-12 blog-main">
              
<article>
  <p class="article-description">
    2016-06-27 <span class="words-count">| 1427 words |</span> How to affect code from deep down the dependency chain</p>
  <p><em>DISCLAIMER: data theft is a serious crime in many jurisdictions. The author
does not condone or encourage anyone to break laws. The information provided
here is for educational purposes only.</em></p>

<p>Back when I wrote about <a href="http://perl6.party/post/Anguish--Invisible-Programming-Language-and-Invisible-Data-Theft">exploiting operators made of invisible Unicode
characters</a>,
a bunch of folks pointed out the module containing rogue
code would actually have to be imported by the victim and it's not that easy to
convince them. Fair enough. Today, we'll play a new game and crank it up a
notch!</p>

<h2 id="thegameplan">The Game Plan</h2>

<p>We all worked on codebases that relied on a dozen of open-sourced modules,
each of which relied on a few more, which in turn relied on... well, you get
the point. Somewhere, a gazillion levels deep, there's some type of a
<a href="http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/">leftpad</a> in use
that you never reviewed for sanity. Right?</p>

<p>So here's our setup:</p>

<pre><code>+--------------+     +-------------+    +------------+
| Rightpad.pm6 |  -&gt; | GoodGuy.pm6 | -&gt; | Target.pm6 |
+--------------+     +-------------+    +------------+
</code></pre>

<p><code>Target.pm6</code> is some code we want to steal stuff from. It uses
<code>GoodGuy.pm6</code> to bring in some functionality, and somewhere down
<code>GoodGuy.pm6</code>'s dependency chain there's <code>Rightpad.pm6</code> that we'll
use to inject rogue code into and hope no one will notice.</p>

<p>In particular, we have these goals:</p>

<ol>
<li>Inject code that will steal data that's being operated on by <code>Target.pm6</code>.
For our purposes, a simple print out of the hijacked data will be our
"exploit." The code can be anything we want really, something that logs to a file
or connects to a server to send the data to a remote endpoint.</li>
<li>The exploit has to be as invisible as possible. We're free to modify
<code>Rightpad.pm6</code> any way we want, but <code>Target.pm6</code>'s and <code>GoodGuy.pm6</code>'s code has
to remain exactly the same, functioning, and with as few signs of foul play as
possible.</li>
</ol>

<h2 id="augmentedreality">Augmented Reality</h2>

<p>The first thing one might think about when trying to change stuff in the
entire app is core type augmentation. Let's try it out:</p>

<pre><code>use MONKEY-TYPING;
augment class Str { method uc {} }

# OUTPUT:
# ===SORRY!=== Error while compiling /home/zoffix/CPANPRC/temp.p6
# Package 'Str' already has a method 'uc' (did you mean to declare
# a multi-method?)
# at /home/zoffix/CPANPRC/temp.p6:2
</code></pre>

<p>We enable the <code>MONKEY-TYPING</code> pragma to acknowledge we're doing Dangerous
Things™ and then try to replace an already-existing <code>uc</code> method on <code>Str</code> type.</p>

<p>Oops! We get an error saying it already exists and we can't replace it.
However, we do get a hint for how we can cheat: a multi.
We just have to get creative and make a multi that'll hijack the
dispatch to the method we're trying to... um... hijack.</p>

<pre><code>use MONKEY-TYPING;
augment class Str {
    multi method uc (Str $str where * :) {
        say "We're in! Someone's trying to uppercase $str";
        nextsame;
    }
}

say 'foo'.uc;

# OUTPUT:
# We're in! Someone's trying to uppercase foo
# FOO
</code></pre>

<p>It worked! We prefix the method definition with <code>multi</code> to indicate it's
a multi-dispatch method. For the invocant, we add a type constraint with
<code>where</code> in the signature, except the condition is just the Whatever Star, which
will always match any <code>Str</code>. The benefit is the dispatch will actually pick
this method first, as the type constraint indicates that it should be narrower
than normal <code>Str</code>.</p>

<p>Lastly, to retain the original functionality of the method we're hijacking,
we simply use <code>nextsame</code> to re-dispatch to the next multi, which would be
the original method that will make the target code behave as it was meant to.</p>

<h2 id="mixingitup">Mixing It Up</h2>

<p>Augmentation is great, but it's a blunt tool. We can get more precision by
mixing in roles into core objects:</p>

<pre><code>'foo' does role {
    method uc {
        say "We're in! Someone's trying to uppercase {self}";
        nextsame;
    }
};

say 'foo'.uc;

# OUTPUT:
# We're in! Someone's trying to uppercase foo
# FOO
</code></pre>

<p>Here, we're doing a runtime mixin with an anonymous role that plugs in
its own version of the <code>uc</code> method. Since this isn't a compile-time composition,
the role doesn't get "inserted" into the class, but rather shadows the original
<code>uc</code> method, so we can still use <code>nextsame</code> to provide the original behaviour.</p>

<p>Now, the problem with the above is (a) we already know the content of the
object is <code>'foo'</code>; and (b) this won't actually cross the module boundary as
the <code>'foo'</code> in <code>Target.pm6</code> will be a different beast, so we can't use it for
our game. However, there <em>are</em> objects we can mix a role into in a useful way;
for example, subroutines.</p>

<pre><code>&amp;say does role {
    method CALL-ME (|c){
        put "We're in! Someone's trying to print {c}";
        put |c;
    }
};

say 'foo';

# OUTPUT:
# We're in! Someone's trying to print BE7457CAF9032DF8A21D7E50B29D75AE5E581F84 /tmp/perl6.party/Rightpad.pm6
# We're in! Someone's trying to print foo
# foo
</code></pre>

<p>We intercept the call to <code>say</code> by defining a <code>CALL-ME</code> method on the
appropriate subroutine object and use a <code>Capture</code> for the signature. (The
first line in the output is from precompilation, if anyone was curious).</p>

<p>Since most of the core subs don't use
<code>CALL-ME</code>s but are natively invokable, we can't <code>nextsame</code> to get the
original functionality. In the above version we attempted to replicate it,
but a sharp eye will notice that <code>put</code> is way different than <code>say</code>. Is there
a way to not re-invent the wheel?</p>

<p>Perl 6's <code>but</code> operator creates a copy of an object and mixes a role into it.
Let's use that feature to our advantage:</p>

<pre><code>my &amp;original-say = &amp;say but role {};
&amp;say does role {
    method CALL-ME (|c){
        original-say "We're in! Someone's trying to print {c}";
        original-say |c;
    }
};

say -∞..∞;

# OUTPUT:
# We're in! Someone's trying to print *..*
# -Inf..Inf
</code></pre>

<p>We use the <code>but</code> operator to mix in an empty role into the sub object handling
<code>say</code> and store it in a variable. Since <code>but</code> creates a copy, we can then
mangle the <code>say</code> without affecting the saved core version. We do it the
same way as last time, with a mixin, and this time we call the saved <code>say</code>
to perform the core function. And there is it! Hijacked core sub without
a need to re-implement it.</p>

<h2 id="wrappingitup">Wrapping It Up</h2>

<p>While you can do some damage with mixins on core objects, when it comes to
subs, there's a smaller hammer for the job:
<a href="https://docs.perl6.org/routine/wrap">wrap</a>.</p>

<pre><code>&amp;say.wrap: sub (|c) {
    put "We're in! Someone's trying to print {c}";
    nextsame;
};

say -∞..∞;

# OUTPUT:
# We're in! Someone's trying to print *..*
# -Inf..Inf
</code></pre>

<p>That looks a lot simpler than the mixin version! We call <code>.wrap</code> on the
<code>Sub</code> we want to wrap into our malicious wrapper and we get the benefit of
being able to call <code>nextcase</code> to perform the original function. Note that
we can't use <code>say</code> inside our wrapper, or we'll cause an infinite loop
of it attempting to call the wrapper once again.</p>

<h1 id="puttingthebitstogether">Putting the bits together</h1>

<p>And so, we have this tree of modules and scripts:</p>

<pre><code>.
├── Rightpad.pm6
├── GoodGuy.pm6
└── test.p6
</code></pre>

<p>And here's the code in them:</p>

<pre><code># Rightpad.pm6
unit class Rightpad;
use MONKEY-TYPING;

&amp;say.wrap: sub (|c) {
    put "We're in! Someone's trying to print {c}";
    nextsame;
};

augment class Str {
    multi method uc (Str $str where * :) {
        put "We're in! Someone's trying to uppercase $str";
        nextsame;
    }
}

# GoodGuy.pm6
unit class GoodGuy;
use Rightpad;

# test.p6
use GoodGuy;
say 'foo'.uc;
</code></pre>

<p>And here's the invocation and output:</p>

<pre><code>$ perl6 -I. test.p6
We're in! Someone's trying to uppercase foo
We're in! Someone's trying to print FOO
FOO
</code></pre>

<p><code>Rightpad.pm6</code> doesn't need to be so close in the dependency chain, it can
be hidden behind dozens and dozens of dependencies. Our script uses
<code>GoodGuy.pm6</code> and doesn't have anything but a core function call and
a core method call. However, due to the code we enjected in <code>Rightpad.pm6</code>,
we were able to intercept the data in both of those calls.</p>

<h2 id="conclusion">Conclusion</h2>

<p>While this exercise was a lot of fun, it did bring to light the reality that
we can't trust dependencies too much. Even if the malicious code is several
dependencies away, it can still affect our code and steal our data.</p>

<p>Why would such code exist? Revenge. Plans for world domination. Or even good
ol' carelessness and ignorance.</p>

<h4 id="footnotes">Footnotes</h4>

<p><small><span>*</span> while writing the blog post, I came across a bug with <code>.wrap</code> where it
caused a segfault when trying to wrap across two module boundaries. This
can be worked around by putting <code>no precompilation</code> in the module with the
wrap and may be already fixed when you read this.</small></p>

</article>

            </div>
          </div>
        </div>
    </div>

    <footer class="blog-footer">
      Follow <a href="https://twitter.com/zoffix">@zoffix</a> on Twitter.
      <p class="icons">
        <a href="https://perl6.org" class="powered-by"
          title="Use Perl 6">Use Perl 6.</a>
        <a href="https://github.com/zoffixznet/perl6.party" class="fork-it"
          title="Fork this blog">Fork this blog.</a>
      </p>
    </footer>


    <script src="https://code.jquery.com/jquery-2.2.3.min.js"
    integrity="sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo="
    crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <script src="/asset/5de5502e58/app.js"></script>
  </body>
</html>
