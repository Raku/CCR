https://perl6.party//post/Perl-6-Core-Hacking-QASTalicious
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:image"
        content="https://rakudo.party/assets/pics/perl6.party.gif">
    <meta name="twitter:image" content="https://rakudo.party/assets/pics/perl6.party.gif">
    <title>Perl 6 Core Hacking: QASTalicious - Perl 6 Party</title>

    <link href="/asset/7b8e23928d/app.css" rel="stylesheet">
  </head>

  <body>

    <div class="blog-masthead">
      <div class="container">
        <nav class="blog-nav">
          <a class="blog-nav-item " href="/">Home</a>
          <a class="blog-nav-item " href="/about">About</a>
          <a class="blog-nav-item feed-nav" href="/feed/">Feed</a>
        </nav>
      </div>
    </div>

    <div class="bg">
        <div class="container">

          <div class="blog-header">
            <h1 class="blog-title">Perl 6 Core Hacking: QASTalicious</h1>
          </div>

          <div class="row">
            <div class="col-sm-12 blog-main">
              
<article>
  <p class="article-description">
    2018-01-26 <span class="words-count">| 6528 words |</span> Overview of &quot;Q&quot; Abstract Syntax Trees + bug fix tutorial</p>
  <p>Over the past month, I spent some time in Rakudo's QAST land writing a few
optimizations, fixing bugs involving warnings, as well as squashing a monster
hive of 10 thunk scoping bugs with a single commit. In today's article,
we'll go over that last feat in detail, as well as learn what QAST is and how
to work with it.</p>

<h1 id="parti:theqast">PART I: The QAST</h1>

<p>"QAST" stands for <em>"Q" Abstract Syntax Tree</em>. The "Q" is there because it's
comes after letter "P", and "P" used to be in "PAST" to stand for <em>"Parrot"</em>,
the name of an earlier, experimental Perl 6 implementation (or rather, its
virtual machine). Let's see what QAST is all about!</p>

<h2 id="dumpingqast">Dumping QAST</h2>

<p>Every Rakudo Perl 6 program
compiles down to a tree of QAST nodes and you can dump that tree if you specify
<code>--target=ast</code> or <code>--target=optimize</code> command line option to <code>perl6</code> when
compiling a program or a module:</p>

<pre><code>$ perl6 --target=ast -e 'say "Hello, World!"'
[...]
- QAST::Op(call &amp;say) &lt;sunk&gt; :statement_id&lt;?&gt; say \"Hello, World!\"
  - QAST::Want &lt;wanted&gt; Hello, World!
    - QAST::WVal(Str)
    - Ss
    - QAST::SVal(Hello, World!)
[...]
</code></pre>

<p>The difference between the <code>--target=ast</code> and <code>--target=optimize</code> is that
the former shows the QAST tree as soon as it has been generated, while
the later shows the QAST tree after the static optimizer has had a go at it.</p>

<p>While the command line option gives you the QAST for the entire program
(excluding modules pre-compiled separately), each
<a href="https://github.com/perl6/nqp/blob/master/src/QAST/Node.nqp"><code>QAST::Node</code> object</a> has a <code>.dump</code> method you can use to dump specific QAST pieces of interest
from within Rakudo's source code.</p>

<p>For example, to examine the QAST generated by the <code>statement</code> token, I'd
find <a href="https://github.com/rakudo/rakudo/blob/49dce163e8182ee726cd1e512a03c29551cc16da/src/Perl6/Actions.nqp#L1396"><code>method statement</code></a> in <code>src/Perl6/Actions.nqp</code> and stick <code>nqp::say('statement QAST: ' ~ $past.dump)</code> close to the end of
the method.</p>

<p>Since Rakudo's compilation takes a couple of minutes for each go, I like to
key my debug dumps on env variables, like this:</p>

<pre><code>nqp::atkey(nqp::getenvhash(),'ZZ1') &amp;&amp; nqp::say('ZZ1: something or other');
...
nqp::atkey(nqp::getenvhash(),'ZZ2') &amp;&amp; nqp::say('ZZ2: something else');
</code></pre>

<p>Then, I can execute the compiled <code>./perl6</code> as if I didn't add anything, and
enable my dumps by running <code>ZZ1=1 ./perl6</code>, <code>ZZ2=1 ./perl6</code>, or both dumps
at the same time with <code>ZZ1=1 ZZ2=1 ./perl6</code>.</p>

<h2 id="viewingqast">Viewing QAST</h2>

<p>Looking at the output of <code>--target</code> dumps in the terminal is sufficient
for a quickie glance at the trees, but for extra assistance you can install
<a href="https://modules.perl6.org/dist/CoreHackers::Q"><code>CoreHackers::Q</code> module</a> that
brings in <code>q</code> command line utility.</p>

<p>Simply prefix your regular <code>perl6</code> invocation with <code>q a</code> or <code>q o</code> to produce
<code>--target=ast</code> and <code>--target=optimize</code> QAST dumps respectively. The program
will generate <code>out.html</code> file in the current directory:</p>

<pre><code>$ q a perl6 -e 'say "Hello, World!"'
$ firefox out.html
</code></pre>

<p>Pop open <a href="https://temp.perl6.party/pub/corehackers-q-sample.html">the generated HTML file</a>
and reap these benefits:</p>

<ul>
<li>Color-coded QAST nodes</li>
<li>Color hints for sunk nodes</li>
<li>Ctrl+Click on any node to collapse it</li>
<li>Muted view of QAST::Want alternatives, makes it easier to ignore them</li>
</ul>

<p>Eventually, I hope to extend this tool and make it more helpful, but at the
time of this writing, that's all it does.</p>

<h2 id="theqastforest">The QAST Forest</h2>

<p>There are four main files in
<a href="https://github.com/rakudo/rakudo/">rakudo's source</a>
where you'd expect to be working with QAST
nodes: <code>src/Perl6/Grammar.nqp</code>, <code>src/Perl6/Actions.nqp</code>, <code>src/Perl6/World.nqp</code>,
and <code>src/Perl6/Optimizer.nqp</code>. If you're using <a href="https://github.com/zoffixznet/z"><code>Z-Script</code> utility</a>, you can even run <code>z q</code> command to open these
four files in <a href="https://github.com/perl6/Atom-as-a-Perl6-IDE"><code>Atom</code> editor</a>.</p>

<p><code>Grammar.nqp</code> is the Perl 6 grammar. <code>Actions.nqp</code> are the actions for it.
<code>World.nqp</code> contains all sorts of helpful routines used by both <code>Grammar.nqp</code>
and <code>Actions.nqp</code> that access them via the <code>$*W</code> dynamic variable containing a
<code>Perl6::World</code> object.
Lastly, <code>Optimizer.nqp</code> contains Rakudo's static optimizer.</p>

<p>The root (of all evil) is the <a href="https://github.com/perl6/nqp/blob/master/src/QAST/Node.nqp"><code>QAST::Node</code> object</a>, with all the other QAST nodes
being its subclasses. Let's review some of the popular ones:</p>

<h3 id="qast::op"><code>QAST::Op</code></h3>

<p><code>QAST::Op</code> nodes are the workhorse of the QAST world. The <code>:op</code> named argument
specifies the name of an <a href="https://github.com/perl6/nqp/blob/master/docs/ops.markdown">NQP op</a> or the name of a <a href="https://github.com/rakudo/rakudo/blob/master/docs/ops.markdown">Rakudo's NQP
extension op</a>
and its children are the arguments:</p>

<p>Here's a <code>say</code> op printing a string value:</p>

<pre><code>QAST::Op.new: :op&lt;say&gt;,
  QAST::SVal.new: :value('Hello, World!');
</code></pre>

<p>And here's a QAST node for a <code>call</code> op that calls Perl 6's <code>infix:&lt;+&gt;</code>
operator; notice how the name of the routine we call is given via <code>:name</code> named
argument:</p>

<pre><code>QAST::Op.new: :op&lt;call&gt;, :name('&amp;infix:&lt;+&gt;'),
  QAST::IVal.new( :value(2)),
  QAST::IVal.new: :value(2)
</code></pre>

<h3 id="qast::val"><code>QAST::*Val</code></h3>

<p>The <code>QAST::SVal</code>, <code>QAST::IVal</code>, <code>QAST::NVal</code>, and <code>QAST::WVal</code> nodes, specify
string, integer, float, and "World" object values respectively. The first three
are the "unboxed" raw values, while World objects are everything else, such
as <a href="https://docs.perl6.org/type/DateTime"><code>DateTime</code></a>,
<a href="https://docs.perl6.org/type/Block"><code>Block</code></a>, or
<a href="https://docs.perl6.org/type/Block"><code>Str</code></a> objects.</p>

<h3 id="qast::want"><code>QAST::Want</code></h3>

<p>Some of the objects can be represented by multiple <code>QAST::*Val</code> nodes, where
the most appropriate value is used depending on what is <em>wanted</em> in the
current context. <code>QAST::Want</code> node contains these alternatives, interleaved
with string markers indicating what those alternatives are.</p>

<p>For example, numeric value <code>42</code> in Perl 6 could be wanted as an object
to call some method on, or as a raw value to be assigned to a native
<code>int</code> variable. The <code>QAST::Want</code> node for it would look like this:</p>

<pre><code>QAST::Want.new:
  QAST::WVal.new(:value($Int-obj))),
  'Ii',
  QAST::IVal.new: :value(42)
</code></pre>

<p>The <code>$Int-obj</code> above would contain an instance of
<a href="https://docs.perl6.org/type/Int"><code>Int</code> type</a> with value set to <code>42</code>. The
<code>Ii</code> marker indicates the following alternative is an integer value and we
provide a <code>QAST::IVal</code> object containing it. The other possible markers are
<code>Nn</code> (float), <code>Ss</code> (string), and <code>v</code> (void context) alternatives.</p>

<p>When these nodes are later converted to bytecode, the most appropriate value
will be selected, with the first child being the "default" value, to be used
when none of the available alternatives make the cut.</p>

<h3 id="qast::var"><code>QAST::Var</code></h3>

<p>These nodes are used for variables and parameters. The <code>:name</code> named argument
specifies the name of the variable and <code>:scope</code> its scope:</p>

<pre><code>QAST::Op.new: :op('bind'),
  QAST::Var.new(:name&lt;$x&gt;, :scope&lt;lexical&gt;, :decl&lt;var&gt;, :returns(int)),
  QAST::IVal.new: :value(0)
</code></pre>

<p>The <code>:decl</code> named arg is present when the node is used for the variable's
declaration (when it's absent, we simply reference the variable) and its
value dictates
what sort of variable it is: <code>var</code> for variables and <code>param</code> for routine
parameters. Several other <code>:decl</code> types, as well as optional arguments
specifying additional configuration of the variable exist. You can find them
discussed in <a href="https://github.com/perl6/nqp/blob/master/docs/qast.markdown#qastvar">the QAST
documentation</a></p>

<h3 id="qast::stmtqast::stmts"><code>QAST::Stmt</code> / <code>QAST::Stmts</code></h3>

<p>These are statement grouping constructs. For example, here, the truthy branch
of an <code>nqp::if</code> contains three <code>nqp::say</code> statements, all grouped inside
<code>QAST::Stmts</code>:</p>

<pre><code>QAST::Op.new: :op&lt;if&gt;,
  QAST::IVal.new(:value(42)),
  QAST::Stmts.new(
    QAST::Op.new( :op&lt;say&gt;, QAST::SVal.new: :value&lt;foo&gt;),
    QAST::Op.new( :op&lt;say&gt;, QAST::SVal.new: :value&lt;bar&gt;),
    QAST::Op.new: :op&lt;say&gt;, QAST::SVal.new: :value&lt;ber&gt;),
  QAST::Op.new: :op&lt;say&gt;, QAST::SVal.new: :value&lt;meow&gt;,
</code></pre>

<p>The singular <code>QAST::Stmt</code> is similar. The difference is it
marks a register allocation boundary, beyond which, any temporaries are
free to be reused. When used correctly, this alternative can result in better
code generation.</p>

<h3 id="qast::block"><code>QAST::Block</code></h3>

<p>This node is both a unit of invocation and a unit of lexical scoping. For
example, code <code>sub foo { say "hello" }</code> might compile to a <code>QAST::Block</code>
like this:</p>

<pre><code>Block (:cuid(1)) &lt;wanted&gt; :IN_DECL&lt;sub&gt; { say \"hello\" }
[...]
  Stmts &lt;wanted&gt; say \"hello\"
    Stmt &lt;wanted final&gt; say \"hello\"
      Want &lt;wanted&gt;
        Op (call &amp;say) &lt;wanted&gt; :statement_id&lt;?&gt; say \"hello\"
          Want &lt;wanted&gt; hello
            WVal (Str)
            - Ss
            SVal (hello)
        - v
        Op (p6sink)
          Op (call &amp;say) &lt;wanted&gt; :statement_id&lt;?&gt; say \"hello\"
            Want &lt;wanted&gt; hello
              WVal (Str)
              - Ss
              SVal (hello)
[...]
</code></pre>

<p>Each block demarcates a lexical scope boundary—this detail comes into play
in Part II of this article, when we'll be going over a fix for a bug.</p>

<h3 id="others">Others</h3>

<p>A few more QAST nodes exist. They're out of scope of this article, but
you may wish to read <a href="https://github.com/perl6/nqp/blob/master/docs/qast.markdown">the documentation</a> or, since some of them are
not appear in those docs, go straight
<a href="https://github.com/perl6/nqp/tree/master/src/QAST">to the source</a>.</p>

<h2 id="executingqasttrees">Executing QAST Trees</h2>

<p>Having a decent familarity with
<a href="https://github.com/perl6/nqp/blob/master/docs/ops.markdown">nqp ops</a>
(as well as <a href="https://github.com/rakudo/rakudo/blob/master/docs/ops.markdown">Rakudo's nqp extensions</a>) is helpful when working with
QAST. A sharp eye would notice in QAST dumps that many <code>QAST::Op</code> nodes
correspond to <code>nqp::*</code> op calls, where <code>:op</code> named argument specifies the name
of the op.</p>

<p>When writing large QAST trees, it's handy to write them down using pure NQP
ops first, and then translate the result into a tree of QAST node objects.
Let's look at a simplified example:</p>

<pre><code>nqp::if(
  nqp::isgt_n(nqp::rand_n(1e0), .5e0),
  nqp::say('Glass half full'),
  nqp::say('Glass half empty'));
</code></pre>

<p>We have NQP op, so we'll start with <code>QAST::Op</code> node, using <code>'if'</code> as the
value for <code>:op</code>. The op takes three positional arguments—the three
ops used for the conditional, the truthy branch, and the falsy branch.
Some of the ops also take float and string values, so we'll use <code>QAST::NVal</code>
and <code>QAST::SVal</code> nodes for those. The result is:</p>

<pre><code>QAST::Op.new(:op('if'),
  QAST::Op.new(:op('isgt_n'),
    QAST::Op.new(:op('rand_n'),
      QAST::NVal.new(:value(1e0))
    ),
    QAST::NVal.new(:value(.5e0))
  ),
  QAST::Op.new(:op('say'),
    QAST::SVal.new(:value('Glass half full'))
  ),
  QAST::Op.new(:op('say'),
    QAST::SVal.new(:value('Glass half empty'))
  )
)
</code></pre>

<p>I find it easier to track the tree's nesting by using parentheses
only when necessary,
preferring <a href="https://docs.perl6.org/language/syntax#Precedence_Drop">colon method call</a> syntax whenever possible:</p>

<pre><code>QAST::Op.new: :op&lt;if&gt;,
  QAST::Op.new(:op&lt;isgt_n&gt;,
    QAST::Op.new(:op&lt;rand_n&gt;,
      QAST::NVal.new: :value(1e0)),
    QAST::NVal.new: :value(.5e0)),
  QAST::Op.new(:op&lt;say&gt;,
    QAST::SVal.new: :value('Glass half full')),
  QAST::Op.new: :op&lt;say&gt;,
    QAST::SVal.new: :value('Glass half empty')
</code></pre>

<p>If a <code>.new</code> is followed by a colon, there aren't any
more nodes on the same level. If <code>.new</code> is followed by an opening parentheses,
there are more sister nodes yet to come.</p>

<p>Due to Rakudo's lengthy compilation, it can be handy to execute your QAST tree
without having to stick it into <code>src/Perl6/Actions.nqp</code> or similar file first.
To some extent, it's possible to do that with a regular Perl 6 program. We'll
simply access <code>Perl6::World</code> object in <code>$*W</code> variable inside a <code>BEGIN</code> block,
where it still exists, and call <code>.compile_time_evaluate</code> method, giving it
an empty variable as the first positional (it expects a <code>Match</code> object for
the tree) and our QAST tree as the second positional:</p>

<pre><code>use QAST:from&lt;NQP&gt;;
BEGIN $*W.compile_time_evaluate: $,
    QAST::Op.new: :op&lt;if&gt;,
      QAST::Op.new(:op&lt;isgt_n&gt;,
        QAST::Op.new(:op&lt;rand_n&gt;,
          QAST::NVal.new: :value(1e0)),
        QAST::NVal.new: :value(.5e0)),
      QAST::Op.new(:op&lt;say&gt;,
        QAST::SVal.new: :value('Glass half full')),
      QAST::Op.new: :op&lt;say&gt;,
        QAST::SVal.new: :value('Glass half empty')
</code></pre>

<p>The one caveat with this method is we're using full-blown Perl 6 language,
whereas in <code>src/Perl6/Actions.nqp</code> and related files, as <code>.nqp</code> extension
suggests, we're using NQP language only. Keep an eye out for strange
explosions; it's possible your QAST tree that explodes in Perl 6 will compile
just fine in the land of pure NQP.</p>

<h2 id="annotatingqastnodes">Annotating QAST Nodes</h2>

<p>All QAST nodes support annotations that allow you to attach an arbitrary value
to a node and then read that value elsewhere. To add an annotation, use
<code>.annotate</code> method, which takes two positional arguments—a string containing
name of the annotation and the value to attach to it—and returns that
value. <a href="https://github.com/perl6/nqp/commit/4e647a70b7e549423ea2fa47e5da51ea8d283d69">Recent</a>
versions of NQP also have <code>.annotate_self</code> method that works the same, except
it returns the QAST node itself:</p>

<pre><code>$qast.annotate_self('foo', 42).annotate: 'bar', 'meow';
</code></pre>

<p>Later, you can read that value using <code>.ann</code> method that takes the name of
the annotation as the argument. If the annotation doesn't exist,
<code>NQPMu</code> is returned instead:</p>

<pre><code>note($qast.ann: 'foo'); # OUTPUT: «42␤»
</code></pre>

<p>You can also check for whether an annotation merely exists using <code>.has_ann</code>
method that returns <code>1</code> (true) or <code>0</code> (false):</p>

<pre><code>note($qast.has_ann: 'bar'); # OUTPUT: «1␤»
</code></pre>

<p>Or dump all of the annotations on the node (to prevent potential flood of
output, most values will be dumped as simply a question mark):</p>

<pre><code>note($qast.dump_annotations); # OUTPUT: « :bar&lt;?&gt; :foo&lt;?&gt;␤»);
</code></pre>

<p>Lasty, to clear all annotations on the node, simply call <code>.clear_annotations</code>
method.</p>

<h2 id="mutatingqastnodes">Mutating QAST Nodes</h2>

<p>A handy thing to do with QAST node objects is to mutate them into something
better. That's essentially all the static optimizer in
<code>src/Perl6/Optimizer.nqp</code> does. Named arguments can be mutated by calling
them as methods and providing a value. For example, <code>$qast.op('callstatic')</code>
will change the value of <code>:op</code> from whatever it is to <code>callstatic</code>. Positional
arguments can be altered by re-assignment to a positional index, as well
as <code>shift</code>, <code>push</code>, <code>unshift</code>, <code>pop</code> operations performed either via method
calls with those names or <code>nqp::</code> ops. Some nodes also support <code>nqp::elems</code>
calls on them, which is slightly faster than the generic pattern of <code>+@($qast)</code>
that can be used on all nodes to find out the number of children a node
contains.</p>

<p>As an exercise, let's write a small optimization: some operations, like
<code>$foo &lt; $bar &lt; $ber</code> compile to <code>nqp::chain</code> ops. That is so even if
we have only two children, e.g. <code>$foo &lt; $bar</code>. In such cases, rewriting
the op to be <code>nqp::call</code> has performance advantages: not only <code>nqp::call</code>
on its own is a little bit faster than <code>nqp::chain</code>, the static optimizer knows
how to do further optimizations on <code>nqp::call</code> ops.</p>

<p>Let's take a look at what both 2-child and 2+-child <code>nqp::chain</code> chains look
like:</p>

<pre><code>$ perl6 --target=ast -e '2 &lt; 3 &lt; 4; 2 &lt; 3'
</code></pre>

<p>The first statement compiled to this (I removed <code>QAST::Want</code>s for clarity):</p>

<pre><code>- QAST::Op(chain &amp;infix:«&lt;»)  :statement_id&lt;?&gt; &lt;
  - QAST::Op(chain &amp;infix:«&lt;») &lt;wanted&gt; &lt;
    - QAST::IVal(2)
    - QAST::IVal(3)
  - QAST::IVal(4)
</code></pre>

<p>And the second one to:</p>

<pre><code>- QAST::Op(chain &amp;infix:«&lt;»)  :statement_id&lt;?&gt; &lt;
  - QAST::IVal(2)
  - QAST::IVal(3)
</code></pre>

<p>Thus, to target our optimization correctly, we need to ensure neither child of
our <code>chain</code> op is a <code>chain</code> op. In addition, we need to ensure that the
op we're optimizing is not itself a child of another <code>chain</code> op.</p>

<p>Raking <a href="https://github.com/rakudo/rakudo/blob/master/src/Perl6/Optimizer.nqp">the code of the optimizer</a>, we can spot that
chain depth is already tracked via <code>$!chain_depth</code> attribute, so we merely need
to ensure we're at the first link of the chain. The code then becomes:</p>

<pre><code>$qast.op: 'call'
  if nqp::istype($qast, QAST::Op)
  &amp;&amp; $qast.op eq 'chain'
  &amp;&amp; $!chain_depth == 1
  &amp;&amp; ! (nqp::istype($qast[0], QAST::Op) &amp;&amp; $qast[0].op eq 'chain')
  &amp;&amp; ! (nqp::istype($qast[1], QAST::Op) &amp;&amp; $qast[1].op eq 'chain');
</code></pre>

<p>Once we find a <code>chain</code> <code>QAST::Op</code>, we index into it and use <code>nqp::istype</code> to
check the type of kid nodes, and if those happen to be <code>QAST::Op</code> nodes,
we ensure the  <code>:op</code> parameter is not a <code>chain</code> op. If all of the conditions are met, we simply call <code>.op</code> method on our node with value <code>'call'</code> to convert
it into a <code>call</code> op.</p>

<p>We then stick our optimization <a href="https://github.com/rakudo/rakudo/blob/1ee89b54074e80c0753a120d679c6265bd8d5d1f/src/Perl6/Optimizer.nqp#L1228-L1235">early enough into <code>.visit_op</code> method of the optimizer</a> and its later portions will
further optimize our <code>call</code>.</p>

<p>A fairly easy and straightforward optimization that can bring a lot of benefit.</p>

<h1 id="partii:athunkinthetrunk">PART II: A Thunk in The Trunk</h1>

<hr />

<p><em>Note: it took me three evenings to debug and fix the following tickets. To
learn the solution I tried many dead ends that I won't be covering, to keep
you from getting bored, and instead will instantly jump to conclusions. The
point I'm making is that fixing core bugs is a lot easier than may seem
from reading this article—you just need to be willing to spend some time
on them.</em></p>

<hr />

<p>Now that we have some familiarity with QAST, let's try to fix a
bug that existed in <a href="https://github.com/rakudo/rakudo/tree/a5c2398cc744706eb81b3d73b181cb4233c85a17">Rakudo <code>v2018.01.30.ga.5.c.2398.cc</code></a>
and earlier. The ticket in question is
<a href="https://github.com/rakudo/rakudo/issues/1212">R#1212</a>, that shows
the following problem:</p>

<pre><code>$ perl6 -e 'say &lt;a b c&gt;[$_ xx 2] with 1'

Use of Nil in string context
  in block  at -e line 1
Unable to call postcircumfix [ (Any) ] with a type object
Indexing requires a defined object
  in block &lt;unit&gt; at -e line 1
</code></pre>

<p>It looks like the <code>$_</code> topical variable inside the indexing brackets fails
to get the value from <code>with</code> statement modifier and ends up being undefined.
Sounds like a challenge!</p>

<h2 id="itsahive">It's A Hive!</h2>

<p>Both <code>with</code> and <code>xx</code> operator create thunks (thunks are like blocks of code,
without having explicit blocks in the code; this, for example, lets
<code>rand xx 10</code> to produce 10 different random values; <code>rand</code> is thunked and the
thunk is called for each iteration). This reminded me of some other tickets
I've seen, so I went to <a href="https://fail.rakudo.party/">fail.rakudo.party</a> and
looked through open tickets for anything that mentioned thunking or wrong
scoping.</p>

<p>I ended up with a list of 7 tickets, and with the help of dogbert++ later
increased the number to 9, which with the original Issue gives us a total
of 10 different manifestations of a bug. The other tickets are
<a href="https://rt.perl.org/Ticket/Display.html?id=130575">RT#130575</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=132337">RT#132337</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=131548">RT#131548</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=132211">RT#132211</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=126569">RT#126569</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=128054">RT#128054</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=126413">RT#126413</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=126984">RT#126984</a>, and
<a href="https://rt.perl.org/Ticket/Display.html?id=132172">RT#132172</a>.
Quite a bug hive!</p>

<h2 id="testitout">Test It Out</h2>

<p>Our starting point is to cover each manifestation of the bug with a test.
Make all the test pass and you know you've fixed the bug, plus you already
have something to place into <a href="https://github.com/perl6/roast/">roast</a>, to
cover the tickets. My tests ended up looking like this, where I've used
<a href="https://docs.perl6.org/syntax/gather%20take"><code>gather</code>/<code>take</code></a> duo to capture
what the tickets' code printed to the screen:</p>

<pre><code>use Test;
plan 1;
subtest 'thunking closure scoping' =&gt; {
    plan 10;

    # https://github.com/rakudo/rakudo/issues/1212
    is-deeply &lt;a b c&gt;[$_ xx 2], &lt;b b&gt;.Seq, 'xx inside `with`' with 1;

    # RT #130575
    is-deeply gather {
        sub itcavuc ($c) { try {take $c} andthen 42 };
        itcavuc $_ for 2, 4, 6;
    }, (2, 4, 6).Seq, 'try with block and andthen';

    # RT #132337
    is-deeply gather {
        sub foo ($str) { { take $str }() orelse Nil }
        foo "cc"; foo "dd";
    }, &lt;cc dd&gt;.Seq, 'block in a sub with orelse';

    # RT #131548
    is-deeply gather for ^7 {
        my $x = 1;
        1 andthen $x.take andthen $x = 2 andthen $x = 3 andthen $x = 4;
    }, 1 xx 7, 'loop + lexical variable plus chain of andthens';

    # RT #132211
    is-deeply gather for &lt;a b c&gt; { $^v.uc andthen $v.take orelse .say },
        &lt;a b c&gt;.Seq, 'loop + andthen + orelse';

    # RT #126569
    is-deeply gather { (.take xx 10) given 42 }, 42 xx 10,
        'parentheses + xx + given';

    # RT #128054
    is-deeply gather { take ("{$_}") for &lt;aa bb&gt; }, &lt;aa bb&gt;.Seq,
        'postfix for + take + block in a string';

    # RT #126413
    is-deeply gather { take (* + $_)(32) given 10 }, 42.Seq,
        'given + whatever code closure execution';

    # RT #126984
    is-deeply gather {
        sub foo($x) { (* ~ $x)($_).take given $x }; foo(1); foo(2)
    }, ("11", "22").Seq, 'sub + given + whatevercode closure execution';

    # RT #132172
    is-deeply gather { sub {
        my $ver =.lines.uc with "totally-not-there".IO.open
            orelse "meow {$_ ~~ Failure}".take and return 42;
    }() }, 'meow True'.Seq, 'sub with `with` + orelse + block interpolation';
}
</code></pre>

<p>When I brought up the first bug in <a href="https://webchat.freenode.net/?channels=#perl6-dev">our dev
chatroom</a>, jnthn++ pointed
out that such bugs are often due to mis-scoped blocks, as <code>p6capturelex</code>
op that's involved needs to be called in the immediate outer of the block
it references.</p>

<p>Looking through the tickets, I also spotted skids++'s note that changing
a conditional for <code>statement_id</code> in <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L9195-L9197">block migrator predicate</a>
fixed one of the tickets.
This wasn't the full story of the fix, as the many still-failing tests showed, but it
was a good start.</p>

<h2 id="whatsyourproblem">What's Your Problem?</h2>

<p>In order to find the best solution for a bug, it's important to understand
what exactly is the problem. We know mis-scoped blocks are the cause of the
bug, so lets grab each of our tests, dump their QAST (<code>--target=ast</code>), and
write out <em>how</em> mis-scoped the blocks are.</p>

<p>To make it easier to match the <code>QAST::Block</code>s with the <code>QAST::WVal</code>s
referencing them, I <a href="https://github.com/perl6/nqp/commit/0264b237930f426f4cba744c55f10813869ac40b">made a modification</a> to <code>QAST::Node.dump</code> to include CUID numbers and <code>statement_id</code> annotations in the dumps.</p>

<p>Going through mosts of the buggy code chunks, we have these results:</p>

<pre><code>is-deeply &lt;a b c&gt;[$_ xx 2], &lt;b b&gt;.Seq, 'xx inside `with`' with 1;
# QAST for `xx` is ALONGSIDE RHS `andthen` thunk, but needs to be INSIDE

is-deeply gather {
    sub itcavuc ($c) { try {take $c} andthen 42 };
    itcavuc $_ for 2, 4, 6;
}, (2, 4, 6).Seq, 'try with block and andthen';
# QAST for try block is INSIDE RHS `andthen` thunk, but needs to be ALONGSIDE

is-deeply gather {
    sub foo ($str) { { take $str }() orelse Nil }
    foo "cc"; foo "dd";
}, &lt;cc dd&gt;.Seq, 'block in a sub with orelse';
# QAST for block is INSIDE RHS `andthen` thunk, but needs to be ALONGSIDE

is-deeply gather for ^7 {
    my $x = 1;
    1 andthen $x.take andthen $x = 2 andthen $x = 3 andthen $x = 4;
}, 1 xx 7, 'loop + lexical variable plus chain of andthens';
# each andthen thunk is nested inside the previous one, but all need to be
# ALONGSIDE each other

is-deeply gather for &lt;a b c&gt; { $^v.uc andthen $v.take orelse .say },
    &lt;a b c&gt;.Seq, 'loop + andthen + orelse';
# andthen's block is INSIDE orelse's but needs to be ALONGSIDE each other

is-deeply gather { (.take xx 10) given 42 }, 42 xx 10,
    'parentheses + xx + given';
# .take thunk is ALONGSIDE given's thunk, but needs to be INSIDE of it

is-deeply gather { take ("{$_}") for &lt;aa bb&gt; }, &lt;aa bb&gt;.Seq,
    'postfix for + take + block in a string';
# the $_ is ALONGSIDE `for`'s thunk, but needs to be INSIDE

is-deeply gather { take (* + $_)(32) given 10 }, 42.Seq,
    'given + whatever code closure execution';
# the WhateverCode ain't got no statement_id and is ALONGSIDE given
# block but needs to be INSIDE of it
</code></pre>

<p>So far, we can see a couple of patterns:</p>

<ul>
<li><a href="https://docs.perl6.org/routine/xx"><code>xx</code></a> and
<a href="https://docs.perl6.org/type/WhateverCode"><code>WhateverCode</code></a> thunks don't
get migrated, even though they should</li>
<li><a href="https://docs.perl6.org/routine/andthen"><code>andthen</code></a> thunks get migrated,
even though they shouldn't</li>
</ul>

<p>The first one is fairly straightforward. Looking at the QAST dump, we see
<code>xx</code> thunk has a higher <code>statement_id</code> than the block it was meant to be in.
This is what skids++'s hint addresses, so we'll
change <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L9196">the <code>statement_id</code> conditional</a> from
<code>==</code> to <code>&gt;=</code> to look for statement IDs higher than our current one as well,
since those would be from any substatements, such as our <code>xx</code> inside the
positional indexing operator:</p>

<pre><code>($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
</code></pre>

<p>The cause is very similar for the <code>WhateverCode</code> case, as it's missing
<code>statement_id</code> annotation altogether, so we'll just annotate
the generated <code>QAST::Block</code> with the statement ID. Some basic detective work
gives us <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L9574">the location where that node is created</a>: we search <code>src/Perl6/Actions.nqp</code> for word <code>"whatever"</code> until we spot
<code>whatever_curry</code> method and in its guts we find the <code>QAST::Block</code> we want. For
the statement ID, we'll grep the source for <code>statement_id</code>:</p>

<pre><code>$ grep -FIRn 'statement_id' src/Perl6/
src/Perl6/Actions.nqp:1497:            $past.annotate('statement_id', $id);
src/Perl6/Actions.nqp:2326:                $_.annotate('statement_id', $*STATEMENT_ID);
src/Perl6/Actions.nqp:2488:                -&gt; $b { ($b.ann('statement_id') // -1) == $stmt.ann('statement_id') });
src/Perl6/Actions.nqp:9235:                &amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
src/Perl6/Actions.nqp:9616:            ).annotate_self: 'statement_id', $*STATEMENT_ID;
src/Perl6/World.nqp:256:            $pad.annotate('statement_id', $*STATEMENT_ID);
</code></pre>

<p>From the output, we can see the ID is stored in <code>$*STATEMENT_ID</code> dynamic
variable, so we'll use that for our annotation <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L9574">on the
<code>WhateverCode</code>'s <code>QAST::Block</code></a>:</p>

<pre><code>my $block := QAST::Block.new(
    QAST::Stmts.new(), $past
).annotate_self: 'statement_id', $*STATEMENT_ID;
</code></pre>

<p>Let's compile and run our bug tests. If you're using
<a href="https://github.com/zoffixznet/z">Z-Script</a>, you can re-compile Rakudo
by running <code>z</code> command with no arguments:</p>

<pre><code>$ z
[...]
$ ./perl6 bug-tests.t
1..1
    1..10
    ok 1 - xx inside `with`
    not ok 2 - try with block and andthen
    # Failed test 'try with block and andthen'
    # at bug-tests.t line 10
    # expected: $(2, 4, 6)
    #      got: $(2, 2, 4)
    not ok 3 - block in a sub with orelse
    # Failed test 'block in a sub with orelse'
    # at bug-tests.t line 16
    # expected: $("cc", "dd")
    #      got: $("cc", "cc")
    not ok 4 - loop + lexical variable plus chain of andthens
    # Failed test 'loop + lexical variable plus chain of andthens'
    # at bug-tests.t line 22
    # expected: $(1, 1, 1, 1, 1, 1, 1)
    #      got: $(1, 4, 3, 3, 3, 3, 3)
    not ok 5 - loop + andthen + orelse
    # Failed test 'loop + andthen + orelse'
    # at bug-tests.t line 28
    # expected: $("a", "b", "c")
    #      got: $("a", "a", "a")
    ok 6 - parentheses + xx + given
    ok 7 - postfix for + take + block in a string
    ok 8 - given + whatever code closure execution
    ok 9 - sub + given + whatevercode closure execution
    not ok 10 - sub with `with` + orelse + block interpolation
    # Failed test 'sub with `with` + orelse + block interpolation'
    # at bug-tests.t line 49
    # expected: $("meow True",)
    #      got: $("meow False",)
    # Looks like you failed 5 tests of 10
not ok 1 - thunking closure scoping
# Failed test 'thunking closure scoping'
# at bug-tests.t line 3
# Looks like you failed 1 test of 1
</code></pre>

<p>Looks like that fixed half of the issues already. That's pretty good!</p>

<h2 id="extradebugging">Extra Debugging</h2>

<p>Let's now look at the remaining failures and figure out why block migration
isn't how we want it in those cases. To assists with our sleuthing efforts,
let's make a couple of changes to produce more debugging info.</p>

<p>First, let's modify <a href="https://github.com/perl6/nqp/blob/d71bd7334c5c9363d49ddf20645e6041af15fa41/src/QAST/Node.nqp#L166"><code>QAST::Node.dump</code> method in NQP's repo</a>
to dump the value of <code>in_stmt_mod</code> annotation, by telling it to dump out
the value verbatim if the key is <code>in_stmt_mod</code>:</p>

<pre><code>if $k eq 'IN_DECL' || $k eq 'BY' || $k eq 'statement_id'
|| $k eq 'in_stmt_mod' {
    ...
</code></pre>

<p>Next, let's go to <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L6535-L6560"><code>sub migrate_blocks</code> in <code>Actions.nqp</code></a> and add a bunch of debug dumps inside most of the
conditionals.
This will let us track when a block is compared and to see whether migration
occurs. As mentioned earlier, I like to key my dumps on env vars using
<code>nqp::getenvhash</code> op, so after modifications my <code>migrate_blocks</code> routine
looks like this; note the use of <code>.dump</code> method to dump QAST node guts
(tip: <code>.dump</code> method also exists on <code>Perl6::Grammar</code>'s match objects!):</p>

<pre><code>sub migrate_blocks($from, $to, $predicate?) {
    my @decls := @($from[0]);
    my int $n := nqp::elems(@decls);
    my int $i := 0;
    while $i &lt; $n {
        my $decl := @decls[$i];
        if nqp::istype($decl, QAST::Block) {
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: -----------------');
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: trying to grab ' ~ $decl.dump);
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: to move to ' ~ $to.dump);
            if !$predicate || $predicate($decl) {
                nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: grabbed');
                $to[0].push($decl);
                @decls[$i] := QAST::Op.new( :op('null') );
            }
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: -----------------');
        }
        elsif (nqp::istype($decl, QAST::Stmt) || nqp::istype($decl, QAST::Stmts)) &amp;&amp;
              nqp::istype($decl[0], QAST::Block) {
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: -----------------');
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: trying to grab ' ~ $decl[0].dump);
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: to move to ' ~ $to.dump);
            if !$predicate || $predicate($decl[0]) {
                nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: grabbed');
                $to[0].push($decl[0]);
                $decl[0] := QAST::Op.new( :op('null') );
            }
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: -----------------');
        }
        elsif nqp::istype($decl, QAST::Var) &amp;&amp; $predicate &amp;&amp; $predicate($decl) {
            $to[0].push($decl);
            @decls[$i] := QAST::Op.new( :op('null') );
        }
        $i++;
    }
}
</code></pre>

<p>After making the changes, we need to recompile both NQP and Rakudo. With
<a href="https://github.com/zoffixznet/z">Z-Script</a>, we can just run <code>z n</code> to do that:</p>

<pre><code>$ z n
[...]
</code></pre>

<p>Now, we'll grab the first failing code and take a look at its QAST. I'm
going to use the <a href="https://modules.perl6.org/dist/CoreHackers::Q"><code>CoreHackers::Q</code> tool</a>:</p>

<pre><code>$ q a ./perl6 -e '
    sub itcavuc ($c) { try {say $c} andthen 42 };
    itcavuc $_ for 2, 4, 6;'
$ firefox out.html
</code></pre>

<p>We can see that our buggy <code>say</code> call lives in <code>QAST::Block</code> with <code>cuid 1</code>,
which gets called from within <code>QAST::Block</code> with <code>cuid 3</code>, but is actually
located within <code>QAST::Block</code> with <code>cuid 2</code>:</p>

<pre><code>- QAST::Block(:cuid(3)) &lt;wanted&gt; :statement_id&lt;1&gt;
        :count&lt;?&gt; :signatured&lt;?&gt; :IN_DECL&lt;sub&gt;
        :in_stmt_mod&lt;0&gt; :code_object&lt;?&gt;
        :outer&lt;?&gt; { try {say $c} andthen 42 }
    [...]
        - QAST::Block(:cuid(2)) &lt;wanted&gt; :statement_id&lt;2&gt;
                :count&lt;?&gt; :in_stmt_mod&lt;0&gt; :code_object&lt;?&gt; :outer&lt;?&gt;
            [...]
            - QAST::Block(:cuid(1)) &lt;wanted&gt; :statement_id&lt;2&gt;
                    :IN_DECL&lt;&gt; :in_stmt_mod&lt;0&gt; :code_object&lt;?&gt;
                    :also_uses&lt;?&gt; :outer&lt;?&gt; {say $c}
                [...]
                - QAST::Op(call &amp;say)  say $c
    [...]
    - QAST::Op(p6typecheckrv)
        [...]
        - QAST::WVal(Block :cuid(1))
</code></pre>

<p>Looks like <code>cuid 2</code> block steals our <code>cuid 1</code> block. Let's enable the
debug env var and look at the dumps to see why exactly:</p>

<pre><code>$ ZZ=1 ./perl6 -e '
    sub itcavuc ($c) { try {say $c} andthen 42 };
    itcavuc $_ for 2, 4, 6;'

ZZ1: -----------------
ZZ1: trying to grab - QAST::Block(:cuid(1)) &lt;wanted&gt;
    :statement_id&lt;2&gt; :IN_DECL&lt;&gt; :in_stmt_mod&lt;0&gt; :code_object&lt;?&gt;
    :also_uses&lt;?&gt; :outer&lt;?&gt; {say $c}
[...]

ZZ1: to move to - QAST::Block  :statement_id&lt;2&gt;
    :in_stmt_mod&lt;0&gt; :outer&lt;?&gt;

ZZ1: grabbed
ZZ1: -----------------
</code></pre>

<p>We can see the theft in progress. Let's take a look at our <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L9196">migration
predicate</a>
again:</p>

<pre><code>! $b.ann('in_stmt_mod')
&amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
</code></pre>

<p>In the dump we can see <code>in_stmt_mod</code> is false. Were it set to a true value,
the block would not be migrated—exactly what we're trying to accomplish.
Let's investigate the <code>in_stmt_mod</code> annotation, to see when it gets set:</p>

<pre><code>$ G 'in_stmt_mod' src/Perl6/Actions.nqp
2327:                $_.annotate('in_stmt_mod', $*IN_STMT_MOD);
9206:                !$b.ann('in_stmt_mod') &amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id

$ G '$*IN_STMT_MOD' src/Perl6/Grammar.nqp
1200:        :my $*IN_STMT_MOD := 0;                    # are we inside a statement modifier?
1328:        :my $*IN_STMT_MOD := 0;
1338:        | &lt;EXPR&gt; :dba('statement end') { $*IN_STMT_MOD := 1 }
</code></pre>

<p>Looks like it's a marker for statement modifier conditions. Statement modifiers
have a lot of relevance to our <code>andthen</code> thunks, because <code>$foo with $bar</code> gets
turned into <code>$bar andthen $foo</code> during parsing. Since, as we can see in
<code>src/Perl6/Grammar.nqp</code>, <code>in_stmt_mod</code> annotation gets set for <code>with</code>
statement modifiers, we can hypothesize that if we turn
our buggy <code>andthen</code> into a <code>with</code>, the bug will disappear:</p>

<pre><code>$ ./perl6 -e 'sub itcavuc ($c) { 42 with try {say $c} };
    itcavuc $_ for 2, 4, 6;'
2
4
6
</code></pre>

<p>And indeed it does! Then, we have a way forward: we need to set <code>in_stmt_mod</code>
annotation to a truthy value for just <em>the first</em> argument of <code>andthen</code>
(and its relatives <code>notandthen</code> and <code>orelse</code>).</p>

<p>Glancing <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Grammar.nqp#L4650-L4651">at the Grammar</a> it doesn't look
like it
immediatelly offers a similar opportunity for how <code>in_stmt_mod</code> is set for the
<code>with</code> statement modifier. Let's approach it differently. Since we care about
this when thunks are created, let's watch for <code>andthen</code> QAST <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L7170">inside
<code>sub thunkity_thunk</code> in Actions</a>,
then descend into its first kid and add
the <code>in_stmt_mod</code> annotation by cheating and using the <code>past_block</code> annotation
on <code>QAST::WVal</code> with the thunk that contains the reference to <code>QAST::Block</code>
we wish to annotate. The code will look something like this:</p>

<pre><code>sub mark_blocks_as_andnotelse_first_arg($ast) {
    if $ast &amp;&amp; nqp::can($ast, 'ann') &amp;&amp; $ast.ann('past_block') {
        $ast.ann('past_block').annotate: 'in_stmt_mod', 1;
    }
    elsif nqp::istype($ast, QAST::Op)
    || nqp::istype($ast, QAST::Stmt)
    || nqp::istype($ast, QAST::Stmts) {
        mark_blocks_as_andnotelse_first_arg($_) for @($ast)
    }
}

sub thunkity_thunk($/,$thunky,$past,@clause) {
    [...]

    my $andnotelse_thunk := nqp::istype($past, QAST::Op)
      &amp;&amp; $past.op eq 'call'
      &amp;&amp; ( $past.name eq '&amp;infix:&lt;andthen&gt;'
        || $past.name eq '&amp;infix:&lt;notandthen&gt;'
        || $past.name eq '&amp;infix:&lt;orelse&gt;');

    while $i &lt; $e {
        my $ast := @clause[$i];
        $ast := $ast.ast if nqp::can($ast,'ast');
        mark_blocks_as_andnotelse_first_arg($ast)
            if $andnotelse_thunk &amp;&amp; $i == 0;
        [...]
</code></pre>

<p>First, we rake <code>$past</code> argument given to <code>thunkity_thunk</code> for a <code>QAST::Op</code>
for <code>nqp::call</code> that calls one of our ops—when we found one, we set
a variable to a truthy value. Then, in the loop, when we're iterating over
the first child node (<code>$i == 0</code>) of these ops, we'll pass its QAST to our
newly minted <code>mark_blocks_as_andnotelse_first_arg</code> routine, inside of which
we recurse over any ops that can have kids and mark anything that
has <code>past_block</code> annotation with truthy <code>in_stmt_mod</code> annotation.</p>

<p>Let's compile our concoction and give the tests another run. Once again,
I'm using <a href="https://github.com/zoffixznet/z">Z-Script</a> to recompile Rakudo:</p>

<pre><code>$ z
[...]
$ ./perl6 bug-tests.t
1..1
    1..10
    ok 1 - xx inside `with`
    ok 2 - try with block and andthen
    ok 3 - block in a sub with orelse
    not ok 4 - loop + lexical variable plus chain of andthens
    # Failed test 'loop + lexical variable plus chain of andthens'
    # at bug-tests.t line 23
    # expected: $(1, 1, 1, 1, 1, 1, 1)
    #      got: $(1, 4, 3, 3, 3, 3, 3)
    ok 5 - loop + andthen + orelse
    ok 6 - parentheses + xx + given
    ok 7 - postfix for + take + block in a string
    ok 8 - given + whatever code closure execution
    ok 9 - sub + given + whatevercode closure execution
    not ok 10 - sub with `with` + orelse + block interpolation
    # Failed test 'sub with `with` + orelse + block interpolation'
    # at bug-tests.t line 50
    # expected: $("meow True",)
    #      got: $("meow False",)
    # Looks like you failed 2 tests of 10
not ok 1 - thunking closure scoping
# Failed test 'thunking closure scoping'
# at bug-tests.t line 4
# Looks like you failed 1 test of 1
</code></pre>

<p>We got closer to the goal, with 80% of the tests now passing! In the first
remaining failure, we already know from our original examination that
chained andthen thunks get nested when they should not—we haven't done anything
to fix that yet. Let's take care of that first.</p>

<h2 id="playingchinesefoodmindgameshttps:www.youtube.comwatchvoqwzuisy9y0">Playing <a href="https://www.youtube.com/watch?v=oqwzuiSy9y0">Chinese Food Mind Games</a></h2>

<p>Looking back out at the fixes we applied already, we have a marker for when
we're working with <code>andthen</code> or its sister ops: the <code>$andnotelse_thunk</code>
variable. It seems fairly straight-forward that if we don't want the thunks
of these ops to migrate, we just need to annotate them appropriately and stick
the check for that annotation into the migration predicate.</p>

<p>In <code>Grammar.nqp</code>, <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Grammar.nqp#L4007-L4009">we can see our ops are configured</a> with the <code>.b</code> thunky, so we'll locate <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L7218-L7223">that branch</a> in
<code>sub thunkity_thunk</code> and pass <code>$andnotelse_thunk</code> variable as a new named param
to the <code>make_topic_block_ref</code> block maker:</p>

<pre><code>...
elsif $type eq 'b' {  # thunk and topicalize to a block
    unless $ast.ann('bare_block') || $ast.ann('past_block') {
        $ast := block_closure(make_topic_block_ref(@clause[$i],
          $ast, :$andnotelse_thunk,
          migrate_stmt_id =&gt; $*STATEMENT_ID));
    }
    $past.push($ast);
}
...
</code></pre>

<p><a href="](https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L9189-L9198)">The block maker</a>
will shove it into the migration predicate, so our block maker code
becomes this:</p>

<pre><code> sub make_topic_block_ref(
    $/, $past, :$copy, :$andnotelse_thunk, :$migrate_stmt_id,
 ) {
    my $block := $*W.push_lexpad($/);

    # Add annotation to thunks of our ops:
    $block.annotate: 'andnotelse_thunk', 1 if $andnotelse_thunk;

    $block[0].push
        QAST::Var.new( :name('$_'), :scope('lexical'), :decl('var') );
    $block.push($past);
    $*W.pop_lexpad();
    if nqp::defined($migrate_stmt_id) {
        migrate_blocks($*W.cur_lexpad(), $block, -&gt; $b {
               ! $b.ann('in_stmt_mod')

            # Don't migrate thunks of our ops:
            &amp;&amp; ! $b.ann('andnotelse_thunk')

            &amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
        });
    }
    ...
</code></pre>

<p>One more compilation cycle and test run:</p>

<pre><code>$ z
[...]
$ ./perl6 bug-tests.t
1..1
    1..10
    ok 1 - xx inside `with`
    ok 2 - try with block and andthen
    ok 3 - block in a sub with orelse
    ok 4 - loop + lexical variable plus chain of andthens
    ok 5 - loop + andthen + orelse
    ok 6 - parentheses + xx + given
    ok 7 - postfix for + take + block in a string
    ok 8 - given + whatever code closure execution
    ok 9 - sub + given + whatevercode closure execution
    not ok 10 - sub with `with` + orelse + block interpolation
    # Failed test 'sub with `with` + orelse + block interpolation'
    # at bug-tests.t line 50
    # expected: $("meow True",)
    #      got: $("meow False",)
    # Looks like you failed 1 test of 10
not ok 1 - thunking closure scoping
# Failed test 'thunking closure scoping'
# at bug-tests.t line 4
# Looks like you failed 1 test of 1
</code></pre>

<p>So close! Just a single test failure remains. Let's give it a close look.</p>

<h2 id="withinandwithout">Within and Without</h2>

<p>Let's repeat our procedure of dumping QASTs as well as enabing the <code>ZZ</code> env
var and looking at what's causing the thunk mis-migration. I'm going to run
a slightly simplified version of the failing test, to keep the cruft out of
QAST dumps. If you're following along, when looking at full QAST dump keep in
mind what I mentioned earlier: <code>with</code> gets rewritten into <code>andthen</code> op call
during parsing.</p>

<pre><code>$ q a ./perl6 -e '.uc with +"a" orelse "meow {$_ ~~ Failure}".say and 42'
$ firefox out.html

- QAST::Block(:cuid(4)) :in_stmt_mod&lt;0&gt;
    [...]
    - QAST::Block(:cuid(1))  :statement_id&lt;1&gt; :in_stmt_mod&lt;1&gt;
      [...]
      - QAST::Op(chain &amp;infix:&lt;~~&gt;) &lt;wanted&gt; :statement_id&lt;2&gt; ~~
        - QAST::Var(lexical $_) &lt;wanted&gt; $_
        - QAST::WVal(Failure) &lt;wanted&gt; Failure
    - QAST::Block(:cuid(2)) :statement_id&lt;1&gt;
        :in_stmt_mod&lt;1&gt; :andnotelse_thunk&lt;1&gt;
      [...]
      - QAST::Op(callmethod Stringy) &lt;wanted&gt;
        - QAST::Op(call) &lt;wanted&gt; {$_ ~~ Failure}
          - QAST::Op(p6capturelex) &lt;wanted&gt; :code_object&lt;?&gt;
            - QAST::Op(callmethod clone)
              - QAST::WVal(Block)

$ ZZ=1 ./perl6 -e '.uc with +"a" orelse "meow {$_ ~~ Failure}".say and 42'
[...]
ZZ1: -----------------
ZZ1: trying to grab - QAST::Block(:cuid(1))
  :statement_id&lt;1&gt; :in_stmt_mod&lt;1&gt;
  [...]
ZZ1: to move to - QAST::Block
  :statement_id&lt;1&gt; :andnotelse_thunk&lt;1&gt; :in_stmt_mod&lt;1&gt;
  [...]
ZZ1: -----------------
</code></pre>

<p>Although <code>QAST::WVal</code> lacks <code>.past_block</code> annotation and so doesn't show
the block's CUID in the dump, just by reading the code dumped around that
QAST, we can
see that the CUID-less block is our <code>QAST::Block :cuid(1)</code>, whose immediate
outer is
<code>QAST::Block :cuid(4)</code>, yet it's called from within
<code>QAST::Block :cuid(2)</code>. It's supposed to get migrated, but that migration
never happens, as we can see when we use the <code>ZZ</code> env var to enable our
debug dumps in the <code>sub migrate_blocks</code>.</p>

<p>We can see why. Here's our current migration predicate (where <code>$b</code> is the
examined block, which in our case is <code>QAST::Block :cuid(1)</code>):</p>

<pre><code>   ! $b.ann('in_stmt_mod')
&amp;&amp; ! $b.ann('andnotelse_thunk')
&amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
</code></pre>

<p>The very first condition prevents our migration, as our block has truthy
<code>in_stmt_mod</code> annotation, because it's part of the <code>with</code>'s condition.
At the same time,
it <em>does</em> need to be migrated because it's part of the <code>andthen</code> thunk that's
inside the statement modifier!</p>

<p>Since we already have <code>$andnotelse_thunk</code> variable in the vicinity of the
migration predicate we can use it to tell us whether we're migrating for the
benefit of our <code>andthen</code> thunk and not the statement modifier. However,
recall that we've used
the very same <code>in_stmt_mod</code> annotation to mark the first argument of <code>andthen</code>
and its brother ops. We need to alter that first.</p>

<p>And so, the <code>sub mark_blocks_as_andnotelse_first_arg</code> we added earlier becomes:</p>

<pre><code>sub mark_blocks_as_andnotelse_first_arg($ast) {
    if $ast &amp;&amp; nqp::can($ast, 'ann') &amp;&amp; $ast.ann('past_block') {
        $ast.ann('past_block').annotate: 'in_stmt_mod_andnotelse', 1;
    }
    ...
</code></pre>

<p>And then we tweak the <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L9195-L9197">migration predicate</a>
to watch for this altered annotation and
to consider the value of <code>$andnotelse_thunk</code> variable:</p>

<pre><code>migrate_blocks($*W.cur_lexpad(), $block, -&gt; $b {
    (    (! $b.ann('in_stmt_mod_andnotelse') &amp;&amp;   $andnotelse_thunk)
      || (! $b.ann('in_stmt_mod')            &amp;&amp; ! $andnotelse_thunk)
    )
    &amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
    &amp;&amp; ! $b.has_ann('andnotelse_thunk')
});
</code></pre>

<p>Thus, we migrate all the blocks with <code>statement_id</code> equal to or higher than
ours and are all of the following:</p>

<ul>
<li><em>Not</em> thunks of actual <code>andthen</code>, <code>notandthen</code>, or <code>orelse</code></li>
<li><em>Not</em> thunks inside a statement modifier, unless they're inside
thunks of <code>andthen</code> or related ops</li>
<li>If we're considering migrating them inside one of the <code>andthen</code>'s thunks,
then also <em>not</em> part of the first argument to <code>andthen</code> (or related ops),
.</li>
</ul>

<p>That's a fancy-pants predicate. Let's compile and see if it gets the job done:</p>

<pre><code>$ z
[...]
$ ./perl6 bug-tests.t
  1..1
    1..10
    ok 1 - xx inside `with`
    ok 2 - try with block and andthen
    ok 3 - block in a sub with orelse
    ok 4 - loop + lexical variable plus chain of andthens
    ok 5 - loop + andthen + orelse
    ok 6 - parentheses + xx + given
    ok 7 - postfix for + take + block in a string
    ok 8 - given + whatever code closure execution
    ok 9 - sub + given + whatevercode closure execution
    ok 10 - sub with `with` + orelse + block interpolation
ok 1 - thunking closure scoping
</code></pre>

<p>Success! Now, let's remove all of the debug statements we added. Then,
recompile and run <code>make stresstest</code>, to ensure we did not break anything else.
With <a href="https://github.com/zoffixznet/z">Z-Script</a>, we can do all that by
just running <code>z ss</code>:</p>

<pre><code>$ z ss
[...]
All tests successful.
Files=1287, Tests=153127, 159 wallclock secs (21.40 usr  3.27 sys + 3418.56 cusr 179.32 csys = 3622.55 CPU)
Result: PASS
</code></pre>

<p>All is green. We can now <a href="https://github.com/rakudo/rakudo/commit/1ee89b54074e80c0753a120d679c6265bd8d5d1f">commit</a>
our fix to <a href="https://github.com/rakudo/rakudo/">Rakudo's repo</a>, then
<a href="https://github.com/perl6/roast/commit/2f2998733a2d8132ce29a16008cc5b3a50d6567f">commit</a> our tests
to the <a href="https://github.com/perl6/roast">roast repo</a>, and all that remains is
closing those 10 tickets we fixed!</p>

<p>Job well done.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Today, we learned quite a bit about QAST: the Abstract Syntax Trees Perl 6
code compiles to in the Rakudo compiler. We examined the common types of QAST
and how to create, annotate, mutate, execute, and dump them for examination.</p>

<p>In the second part of the article, we applied our new knowledge to fix
a hive of mis-scoped thunking bugs that plagued various Perl 6 constructs.
We introspected the generated QAST nodes to specially annotate them, and then
used those annotations to reconfigure migration predicate, so that it migrates
the blocks correctly.</p>

<p>Hopefully, this knowledge inspires you to fix the many other bugs we <a href="https://fail.rakudo.party/">have on
the RT tracker</a> as well as <a href="https://github.com/rakudo/rakudo/issues">our GitHub Issue
tracker</a></p>

<p>-Ofun</p>

</article>

            </div>
          </div>
        </div>
    </div>

    <footer class="blog-footer">
      Follow <a href="https://twitter.com/zoffix">@zoffix</a> on Twitter.
      <p class="icons">
        <a href="https://perl6.org" class="powered-by"
          title="Use Perl 6">Use Perl 6.</a>
        <a href="https://github.com/zoffixznet/perl6.party" class="fork-it"
          title="Fork this blog">Fork this blog.</a>
      </p>
    </footer>


    <script src="https://code.jquery.com/jquery-2.2.3.min.js"
    integrity="sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo="
    crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <script src="/asset/5de5502e58/app.js"></script>
  </body>
</html>
